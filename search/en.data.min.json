[{"id":0,"href":"/purple/reference/","title":"Reference","parent":"Async MQTT","content":"Streams      stream client_stream  "},{"id":1,"href":"/purple/","title":"Async MQTT","parent":"","content":""},{"id":2,"href":"/purple/reference/stream/","title":"purple::stream","parent":"Reference","content":"template\u0026lt;class NextLayer\u0026gt; class stream; purple::stream is a low level stream to read and write MQTT messages on the binary format specified by the MQTT standard.\nNo validation of the validity of messages is done, it simply makes sure to send data using the correct wire format.\nTypes        Name Description     executor_type The type of executor associated with the stream   next_layer_type The type of the next layer stream     Member functions        Name Description     async_read Read a complete message asynchronously.   async_write Write a complete message asynchronously.   get_executor Get the executor associated with the object.   next_layer Get a reference to the next layer.   reset Reset the stream to prepare for a new connection.   stream Constructor.    "},{"id":3,"href":"/purple/reference/stream/async_read/","title":"purple::stream::async_read","parent":"purple::stream","content":"Overload 1 of 2     template\u0026lt;class DynamicBuffer, class ReadHandler\u0026gt; DEDUCED async_read(DynamicBuffer \u0026amp;buffer, ReadHandler \u0026amp;\u0026amp;handler); This function is used to asynchronously read a complete message. This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:\n A complete message is received. An error occurs.  The algorithm, known as a composed asynchronous operation, is implemented in terms of calls to the next layers async_read_some. The program must ensure that no other calls to async_read are performed until this operation completes. Received message data is appended to the buffer, starting with the first byte of the variable header.\nParameters     buffer     A dynamic buffer to append the message to. The buffer will contain the variable header and the payload. The buffer will not contain the fixed header portion.\nhandler     The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be:\nvoid handler( error_code const\u0026amp; ec, // Result of operation purple::fixed_header header // The fixed header data of the message ); Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using net::post.\nOverload 2 of 2     template\u0026lt;class ReadHandler\u0026gt; DEDUCED async_read(const boost::asio::mutable_buffer \u0026amp;buffer, ReadHandler \u0026amp;\u0026amp;handler); Works the same as Overload 1 of 2 but uses a fixed sized buffer instead of a growable dynamic buffer.\nIf the message doesn\u0026rsquo;t fit in the provided buffer no bytes will be read and ec will be set to purple::error::message_too_large.\nParameters     buffer     A mutable buffer that the message will be read to. The buffer will contain the variable header and the payload. The buffer will not contain the fixed header.\nhandler     The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be:\nvoid handler( error_code const\u0026amp; ec, // Result of operation purple::fixed_header header // The fixed header data of the message ); Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using net::post.\n"},{"id":4,"href":"/purple/reference/stream/async_write/","title":"purple::stream::async_write","parent":"purple::stream","content":"template\u0026lt;class ConstBufferSequence, class WriteHandler\u0026gt; DEDUCED async_write(uint8_t first_byte, const ConstBufferSequence \u0026amp;buffer, WriteHandler \u0026amp;\u0026amp;handler); This function is used to asynchronously write a complete message. This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:\n The complete message is written. An error occurs.  The algorithm, known as a composed asynchronous operation, is implemented in terms of calls to the next layers async_write_some function. The program must ensure that no other calls to async_write are performed until this operation completes.\nThe variable length field of the fixed header is calculated internally, therefore the first byte of buffer must be the first byte of the variable header (if any) or payload (if any).\nIf the entire message, including the fixed header, fits inside the internal write buffer the data will be copied from buffer to the internal write buffer before writing the data to the stream. Otherwise, the write will be done in two stages; first writing the fixed header and then the data in buffer.\nExceptions        Type Thrown on     std::length_error If beast::buffer_bytes(buffer) \u0026gt; 268'435'455    Parameters     first_byte     The first byte of the MQTT message. The first byte contains the control packet type and flags.\nbuffer     A buffer sequence containing the variable header and payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.\nhandler     The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be:\nvoid handler( error_code const\u0026amp; ec, // Result of operation std::size_t bytes_transferred // Total number of bytes sent  // including complete fixed header.  // If no errors occurred this will be greater  // than the buffer_size. ); Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using net::post.\n"},{"id":5,"href":"/purple/reference/stream/executor_type/","title":"purple::stream::executor_type","parent":"purple::stream","content":"using executor_type = boost::beast::executor_type\u0026lt;NextLayer\u0026gt;; The type of executor associated with the object.\n"},{"id":6,"href":"/purple/reference/stream/get_executor/","title":"purple::stream::get_executor","parent":"purple::stream","content":"executor_type get_executor(); This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.\nReturn value     A copy of the executor that the stream will use to dispatch handlers.\n"},{"id":7,"href":"/purple/reference/stream/next_layer/","title":"purple::stream::next_layer","parent":"purple::stream","content":"Overload 1 of 2     next_layer_type\u0026amp; next_layer(); This function returns a reference to the next layer in a stack of stream layers.\nReturn value     A reference to the next layer in a stack of stream layers.\n Overload 2 of 2     const next_layer_type\u0026amp; next_layer() const; This function returns a reference to the next layer in a stack of stream layers.\nReturn value     A reference to the next layer in a stack of stream layers.\n"},{"id":8,"href":"/purple/reference/stream/next_layer_type/","title":"purple::stream::next_layer_type","parent":"purple::stream","content":"using next_layer_type = NextLayer; The type of the next layer.\n"},{"id":9,"href":"/purple/reference/stream/reset/","title":"purple::stream::reset","parent":"purple::stream","content":"void reset() Resets the internal state of the stream. This must be called if the connection is re-established before the stream can be used.\n"},{"id":10,"href":"/purple/reference/stream/constructors/","title":"purple::stream::stream","parent":"purple::stream","content":"Overload 1 of 3     stream(stream\u0026amp;\u0026amp;); If NextLayer is move constructible, this function will move-construct a new stream from the existing stream. After the move, the only valid operation on the moved-from object is destruction.\n Overload 2 of 3     template\u0026lt;class...Args\u0026gt; stream(size_t read_buffer_size, size_t write_buffer_size, Args\u0026amp;\u0026amp;...args); Create an MQTT stream and construct the NextLayer type using args.... The size of the internal read buffer is controlled by read_buffer_size, and the size of the internal write buffer is controlled by write_buffer_size.\nExceptions        Type Thrown on     std::length_error If read_buffer_size \u0026lt; 5 or write_buffer_size \u0026lt; 5.   Any exceptions thrown by the NextLayer constructor.    Parameters     read_buffer_size     The size of the internal read buffer. Must be at least 5.\nwrite_buffer_size     The size of the internal write buffer. Must be at least 5.\nargs     The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layers constructor.\n Overload 3 of 3     template\u0026lt;class...Args\u0026gt; explicit stream(Args\u0026amp;\u0026amp;...args); Create an MQTT stream and construct the NextLayer type using args.... Uses default internal buffers of 1024 bytes.\nExceptions        Type Thrown on     Any exceptions thrown by the NextLayer constructor.    Parameters     args     The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layers constructor.\n "},{"id":11,"href":"/purple/reference/v311/","title":"purple::v311","parent":"Reference","content":""},{"id":12,"href":"/purple/reference/v311/client_stream/","title":"purple::v311::client_stream","parent":"purple::v311","content":"template\u0026lt;class NextLayer\u0026gt; class client_stream; purple::v311::client_stream is a stream suitable for a client connection. Internally it uses an purple::stream but for all intents and purposes this is hidden and should be treated mostly as an implementation detail.\nTypes        Name Description     executor_type The type of executor associated with the stream   next_layer_type The type of the next layer stream     Member functions        Name Description     async_handshake Handshake with a server asynchronously.   get_executor Get the executor associated with the object.   next_layer Get a reference to the next layer.   client_stream Constructor.    "},{"id":13,"href":"/purple/reference/v311/client_stream/constructors/","title":"purple::v311::client_stream","parent":"purple::v311::client_stream","content":"Overload 1 of 2     client_stream(client_stream\u0026amp;\u0026amp;); If purple::stream\u0026lt;NextLayer\u0026gt; is move constructible, this function will move-construct a new stream from the existing stream. After the move, the only valid operation on the moved-from object is destruction.\n Overload 2 of 2     template\u0026lt;class... Args\u0026gt; explicit client_stream(Args \u0026amp;\u0026amp;...args); Create an MQTT stream and construct the purple::stream\u0026lt;NextLayer\u0026gt; type usingargs.... See purple::stream::stream for available constructors.\nExceptions        Type Thrown on     Any exceptions thrown by the purple::stream\u0026lt;NextLayer\u0026gt; constructor.    Parameters     args     The arguments to be passed to initialize the stream object. The arguments are forwarded to the stream constructor.\n"},{"id":14,"href":"/purple/reference/v311/client_stream/async_handshake/","title":"purple::v311::client_stream::async_handshake","parent":"purple::v311::client_stream","content":"template\u0026lt;class WriteHandler = boost::asio::default_completion_token_t\u0026lt;executor_type\u0026gt;\u0026gt; DEDUCED async_handshake(const connect_opts \u0026amp;opts, WriteHandler \u0026amp;\u0026amp;handler = boost::asio::default_completion_token_t\u0026lt;executor_type\u0026gt;{}) This function is used to asynchronously perform a handshake with a server. This is done by first sending a CONNECT message and then waiting for a message from the server. If the message received from the server isn\u0026rsquo;t a CONNACK message (or the CONNACK doesn\u0026rsquo;t signal success) ec will be set to an error. This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:\n A message is received. An error occurs.  The algorithm, known as a composed asynchronous operation, is implemented in terms of calls to the next layers async_write_some function. The program must ensure that no other calls to async_write are performed until this operation completes.\nThe connect options will be copied to an internal buffer used when sending the connect message. The caller can therefore discard that data immediately after the call has returned.\nParameters     opts     The options to use to build the CONNECT message.\nhandler     The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be:\nvoid handler( error_code const\u0026amp; ec, // Result of operation bool session_present // Whether server response  // indicated session present or not. ); Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using net::post.\n"},{"id":15,"href":"/purple/reference/v311/client_stream/executor_type/","title":"purple::v311::client_stream::executor_type","parent":"purple::v311::client_stream","content":"using executor_type = typename purple::stream\u0026lt;NextLayer\u0026gt;::executor_type; The type of executor associated with the object.\n"},{"id":16,"href":"/purple/reference/v311/client_stream/get_executor/","title":"purple::v311::client_stream::get_executor","parent":"purple::v311::client_stream","content":"executor_type get_executor(); This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.\nReturn value     A copy of the executor that the stream will use to dispatch handlers.\n"},{"id":17,"href":"/purple/reference/v311/client_stream/next_layer/","title":"purple::v311::client_stream::next_layer","parent":"purple::v311::client_stream","content":"Overload 1 of 2     next_layer_type\u0026amp; next_layer(); This function returns a reference to the next layer in a stack of stream layers.\nReturn value     A reference to the next layer in a stack of stream layers.\n Overload 2 of 2     const next_layer_type\u0026amp; next_layer() const; This function returns a reference to the next layer in a stack of stream layers.\nReturn value     A reference to the next layer in a stack of stream layers.\n"},{"id":18,"href":"/purple/reference/v311/client_stream/next_layer_type/","title":"purple::v311::client_stream::next_layer_type","parent":"purple::v311::client_stream","content":"using next_layer_type = NextLayer; The type of the next layer.\n"},{"id":19,"href":"/purple/tags/","title":"Tags","parent":"Async MQTT","content":""}]