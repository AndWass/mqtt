[{"id":0,"href":"/mqtt/reference/","title":"Reference","parent":"Async MQTT","content":"Low level primitives      stream  "},{"id":1,"href":"/mqtt/","title":"Async MQTT","parent":"","content":""},{"id":2,"href":"/mqtt/reference/stream/","title":"mqtt::stream","parent":"Reference","content":"template\u0026lt;class NextLayer\u0026gt; class stream; mqtt::stream is a low level stream to read and write MQTT messages on the binary format specified by the MQTT standard.\nNo validation of the validity of messages is done, it simply makes sure to send data using the correct wire format.\nTypes        Name Description     executor_type The type of executor associated with the stream   next_layer_type The type of the next layer stream     Member functions        Name Description     async_read Read a complete message asynchronously.   async_write Write a complete message asynchronously.   async_write_short Write a short message asynchronously.   get_executor Get the executor associated with the object.   next_layer Get a reference to the next layer.   reset Reset the stream to prepare for a new connection.   stream Constructor.    "},{"id":3,"href":"/mqtt/reference/stream/async_read/","title":"mqtt::stream::async_read","parent":"mqtt::stream","content":"template\u0026lt;class DynamicBuffer, class ReadHandler\u0026gt; DEDUCED async_read(DynamicBuffer \u0026amp;buffer, ReadHandler \u0026amp;\u0026amp;handler); This function is used to asynchronously read a complete message. This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:\n A complete message is received. An error occurs.  The algorithm, known as a composed asynchronous operation, is implemented in terms of calls to the next layers async_read_some. The program must ensure that no other calls to async_read are performed until this operation completes. Received message data is appended to the buffer, starting with the first byte of the variable header.\nParameters     buffer     A dynamic buffer to append the message to. The buffer will contain the variable header and the payload. The buffer will not contain the fixed header portion.\nhandler     The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be:\nvoid handler( error_code const\u0026amp; ec, // Result of operation mqtt::fixed_header header // The fixed header data of the message ); Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using net::post.\n"},{"id":4,"href":"/mqtt/reference/stream/async_write/","title":"mqtt::stream::async_write","parent":"mqtt::stream","content":"template\u0026lt;class ConstBufferSequence, class WriteHandler\u0026gt; DEDUCED async_write(uint8_t first_byte, const ConstBufferSequence \u0026amp;buffer, WriteHandler \u0026amp;\u0026amp;handler); This function is used to asynchronously write a complete message. This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:\n The complete message is written. An error occurs.  The algorithm, known as a composed asynchronous operation, is implemented in terms of calls to the next layers async_write_some function. The program must ensure that no other calls to async_write are performed until this operation completes.\nThe variable length field of the fixed header is calculated internally, therefore the first byte of buffer must be the first byte of the variable header (if any) or payload (if any).\nExceptions        Type Thrown on     std::length_error If beast::buffer_bytes(buffer) \u0026gt; 268'435'455    Parameters     first_byte     The first byte of the MQTT message. The first byte contains the control packet type and flags.\nbuffer     A buffer sequence containing the variable header and payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.\nhandler     The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be:\nvoid handler( error_code const\u0026amp; ec, // Result of operation std::size_t bytes_transferred // Total number of bytes sent  // including complete fixed header.  // If no errors occurred this will be greater  // than the buffer_size. ); Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using net::post.\n"},{"id":5,"href":"/mqtt/reference/stream/async_write_short/","title":"mqtt::stream::async_write_short","parent":"mqtt::stream","content":"template\u0026lt;class WriteHandler\u0026gt; DEDUCED async_write_short(uint8_t first_byte, std::array\u0026lt;uint8_t, 3\u0026gt; payload, uint8_t payload_length, WriteHandler \u0026amp;\u0026amp;handler) This is a helper function that utilizes the internal fixed header write buffer to write short messages, with a payload no greater than 3 bytes.\nThis is useful for sending things like PINGREQ or other short control frames that can be sent without having to go through a secondary buffer.\nExceptions        Type Thrown on     std::length_error If payload_length \u0026gt; payload.size().    Parameters     first_byte     The first byte of the MQTT message. The first byte contains the control packet type and flags.\npayload     The payload to send.\npayload_length     Number of payload bytes to actually send.\nhandler     The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be:\nvoid handler( error_code const\u0026amp; ec, // Result of operation std::size_t bytes_transferred // Total number of bytes sent  // including complete fixed header. ); Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using net::post.\n"},{"id":6,"href":"/mqtt/reference/stream/executor_type/","title":"mqtt::stream::executor_type","parent":"mqtt::stream","content":"using executor_type = boost::beast::executor_type\u0026lt;NextLayer\u0026gt;; The type of executor associated with the object.\n"},{"id":7,"href":"/mqtt/reference/stream/get_executor/","title":"mqtt::stream::get_executor","parent":"mqtt::stream","content":"executor_type get_executor(); This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.\nReturn value     A copy of the executor that the stream will use to dispatch handlers.\n"},{"id":8,"href":"/mqtt/reference/stream/next_layer/","title":"mqtt::stream::next_layer","parent":"mqtt::stream","content":"Overload 1 of 2     next_layer_type\u0026amp; next_layer(); This function returns a reference to the next layer in a stack of stream layers.\nReturn value     A reference to the next layer in a stack of stream layers.\n Overload 2 of 2     const next_layer_type\u0026amp; next_layer() const; This function returns a reference to the next layer in a stack of stream layers.\nReturn value     A reference to the next layer in a stack of stream layers.\n"},{"id":9,"href":"/mqtt/reference/stream/next_layer_type/","title":"mqtt::stream::next_layer_type","parent":"mqtt::stream","content":"using next_layer_type = NextLayer; The type of the next layer.\n"},{"id":10,"href":"/mqtt/reference/stream/reset/","title":"mqtt::stream::reset","parent":"mqtt::stream","content":"void reset() Resets the internal state of the stream. This must be called if the connection is re-established before the stream can be used.\n"},{"id":11,"href":"/mqtt/reference/stream/constructors/","title":"mqtt::stream::stream","parent":"mqtt::stream","content":"Overload 1 of 3     stream(stream\u0026amp;\u0026amp;); If NextLayer is move constructible, this function will move-construct a new stream from the existing stream. After the move, the only valid operation on the moved-from object is destruction.\n Overload 2 of 3     template\u0026lt;class...Args\u0026gt; explicit stream(size_t read_buffer_size, Args\u0026amp;\u0026amp;...args); Create an MQTT stream and construct the NextLayer type using args.... The size of the internal read buffer is controlled by read_buffer_size.\nExceptions        Type Thrown on     std::length_error If read_buffer_size \u0026lt; 5.   Any exceptions thrown by the NextLayer constructor.    Parameters     read_buffer_size     The size of the internal read buffer. Must be at least 5.\nargs     The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layers constructor.\n Overload 3 of 3     template\u0026lt;class...Args\u0026gt; explicit stream(Args\u0026amp;\u0026amp;...args); Create an MQTT stream and construct the NextLayer type using args.... Uses a default internal buffer of 1024 bytes.\nExceptions        Type Thrown on     Any exceptions thrown by the NextLayer constructor.    Parameters     args     The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layers constructor.\n "},{"id":12,"href":"/mqtt/tags/","title":"Tags","parent":"Async MQTT","content":""}]